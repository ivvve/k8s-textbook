# Chapter 9: Components and Reusability

## Learning Objectives

By the end of this chapter, you will be able to:
- Understand Kustomize components and their role in promoting reusability
- Create shared components for common infrastructure patterns
- Compose applications from multiple reusable components
- Share components across teams and projects effectively
- Design component libraries for enterprise-scale deployments

## Understanding Kustomize Components

Components are reusable pieces of Kustomize configuration that can be shared across multiple applications and environments. Unlike bases and overlays, components are designed to be mixed and matched to compose complex applications from standardized building blocks.

### Components vs Bases vs Overlays

```mermaid
graph TD
    A[Application Composition] --> B[Base]
    A --> C[Components]
    A --> D[Overlays]
    
    B --> B1[Core Application<br/>Required Resources<br/>Single Purpose]
    C --> C1[Optional Features<br/>Reusable Across Apps<br/>Mix and Match]
    D --> D1[Environment Config<br/>Patches & Customization<br/>Final Assembly]
    
    C --> C2[Database Component]
    C --> C3[Monitoring Component]
    C --> C4[Security Component]
    C --> C5[Logging Component]
```

### When to Use Components

**Use Components for:**
- Optional features that can be enabled/disabled
- Infrastructure patterns repeated across applications
- Cross-cutting concerns (monitoring, security, logging)
- Shared services and utilities
- Team-specific standards and policies

**Use Bases for:**
- Core application resources
- Required foundational configuration
- Application-specific logic

## Creating Your First Component

Let's start with a simple monitoring component that can be added to any application.

### Basic Monitoring Component

**components/monitoring/kustomization.yaml**:
```yaml
apiVersion: kustomize.config.k8s.io/v1alpha1
kind: Component

# Component metadata
metadata:
  name: monitoring-component
  annotations:
    config.kubernetes.io/local-config: "true"
    component.kustomize.io/description: "Adds Prometheus monitoring capabilities"

# Resources provided by this component
resources:
  - servicemonitor.yaml
  - prometheus-rule.yaml

# Patches applied by this component
patches:
  - path: monitoring-annotations.yaml
    target:
      kind: Deployment

# ConfigMaps generated by this component
configMapGenerator:
  - name: monitoring-config
    literals:
      - METRICS_ENABLED=true
      - METRICS_PORT=9090
      - METRICS_PATH=/metrics

# Labels added by this component
commonLabels:
  monitoring.enabled: "true"

# Annotations added by this component
commonAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "9090"
  prometheus.io/path: "/metrics"
```

**components/monitoring/servicemonitor.yaml**:
```yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: app-metrics
  labels:
    component: monitoring
spec:
  selector:
    matchLabels:
      monitoring.enabled: "true"
  endpoints:
  - port: metrics
    path: /metrics
    interval: 30s
    scrapeTimeout: 10s
```

**components/monitoring/prometheus-rule.yaml**:
```yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: app-alerts
  labels:
    component: monitoring
spec:
  groups:
  - name: app.rules
    rules:
    - alert: HighErrorRate
      expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High error rate detected"
        description: "Error rate is {{ $value }} for {{ $labels.instance }}"
    
    - alert: HighMemoryUsage
      expr: container_memory_usage_bytes / container_spec_memory_limit_bytes > 0.9
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "High memory usage"
        description: "Memory usage is {{ $value | humanizePercentage }} for {{ $labels.pod }}"
```

**components/monitoring/monitoring-annotations.yaml**:
```yaml
# Patch to add monitoring annotations to deployments
apiVersion: apps/v1
kind: Deployment
metadata:
  name: placeholder
spec:
  template:
    metadata:
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9090"
        prometheus.io/path: "/metrics"
    spec:
      containers:
      - name: placeholder
        ports:
        - containerPort: 9090
          name: metrics
          protocol: TCP
```

### Using the Monitoring Component

**app-with-monitoring/kustomization.yaml**:
```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

# Base application
resources:
  - ../base

# Include monitoring component
components:
  - ../components/monitoring

# Application-specific configuration
commonLabels:
  app: my-web-app
```

## Database Component

Let's create a comprehensive database component with PostgreSQL, including backup and monitoring.

### Database Component Structure

```
components/database/
├── kustomization.yaml
├── postgres-deployment.yaml
├── postgres-service.yaml
├── postgres-configmap.yaml
├── backup-cronjob.yaml
├── postgres-exporter.yaml
└── network-policy.yaml
```

**components/database/kustomization.yaml**:
```yaml
apiVersion: kustomize.config.k8s.io/v1alpha1
kind: Component

metadata:
  name: database-component
  annotations:
    config.kubernetes.io/local-config: "true"
    component.kustomize.io/description: "PostgreSQL database with backup and monitoring"
    component.kustomize.io/version: "1.0.0"

resources:
  - postgres-deployment.yaml
  - postgres-service.yaml
  - postgres-configmap.yaml
  - backup-cronjob.yaml
  - postgres-exporter.yaml
  - network-policy.yaml

secretGenerator:
  - name: postgres-secrets
    literals:
      - POSTGRES_USER=appuser
      - POSTGRES_PASSWORD=changeme123
      - POSTGRES_DB=appdb

configMapGenerator:
  - name: postgres-config
    literals:
      - POSTGRES_MAX_CONNECTIONS=100
      - POSTGRES_SHARED_BUFFERS=256MB
      - POSTGRES_EFFECTIVE_CACHE_SIZE=1GB
      - BACKUP_RETENTION_DAYS=7

commonLabels:
  component: database
  database.type: postgresql

commonAnnotations:
  component.kubernetes.io/description: "PostgreSQL database component"
```

**components/database/postgres-deployment.yaml**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
  labels:
    app: postgres
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:13-alpine
        ports:
        - containerPort: 5432
          name: postgres
        env:
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: postgres-secrets
              key: POSTGRES_USER
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secrets
              key: POSTGRES_PASSWORD
        - name: POSTGRES_DB
          valueFrom:
            secretKeyRef:
              name: postgres-secrets
              key: POSTGRES_DB
        - name: PGDATA
          value: /var/lib/postgresql/data/pgdata
        resources:
          requests:
            memory: "512Mi"
            cpu: "200m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        volumeMounts:
        - name: postgres-data
          mountPath: /var/lib/postgresql/data
        - name: postgres-config
          mountPath: /etc/postgresql/postgresql.conf
          subPath: postgresql.conf
          readOnly: true
        livenessProbe:
          exec:
            command:
            - pg_isready
            - -U
            - $(POSTGRES_USER)
            - -d
            - $(POSTGRES_DB)
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command:
            - pg_isready
            - -U
            - $(POSTGRES_USER)
            - -d
            - $(POSTGRES_DB)
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: postgres-data
        persistentVolumeClaim:
          claimName: postgres-data
      - name: postgres-config
        configMap:
          name: postgres-config

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-data
  labels:
    app: postgres
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

**components/database/postgres-exporter.yaml**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres-exporter
  labels:
    app: postgres-exporter
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres-exporter
  template:
    metadata:
      labels:
        app: postgres-exporter
    spec:
      containers:
      - name: postgres-exporter
        image: prometheuscommunity/postgres-exporter:latest
        ports:
        - containerPort: 9187
          name: metrics
        env:
        - name: DATA_SOURCE_NAME
          valueFrom:
            secretKeyRef:
              name: postgres-exporter-secret
              key: DATA_SOURCE_NAME
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"

---
apiVersion: v1
kind: Secret
metadata:
  name: postgres-exporter-secret
  labels:
    app: postgres-exporter
type: Opaque
stringData:
  DATA_SOURCE_NAME: "postgresql://appuser:changeme123@postgres:5432/appdb?sslmode=disable"

---
apiVersion: v1
kind: Service
metadata:
  name: postgres-exporter
  labels:
    app: postgres-exporter
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "9187"
spec:
  ports:
  - port: 9187
    targetPort: 9187
    name: metrics
  selector:
    app: postgres-exporter
```

**components/database/backup-cronjob.yaml**:
```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: postgres-backup
  labels:
    component: database
    job-type: backup
spec:
  schedule: "0 2 * * *"  # Daily at 2 AM
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: postgres-backup
            image: postgres:13-alpine
            command:
            - /bin/bash
            - -c
            - |
              BACKUP_FILE="/backup/backup-$(date +%Y%m%d_%H%M%S).sql"
              pg_dump -h postgres -U $POSTGRES_USER -d $POSTGRES_DB > $BACKUP_FILE
              gzip $BACKUP_FILE
              
              # Clean old backups
              find /backup -name "*.sql.gz" -mtime +$BACKUP_RETENTION_DAYS -delete
              
              echo "Backup completed: $BACKUP_FILE.gz"
            env:
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: postgres-secrets
                  key: POSTGRES_USER
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: postgres-secrets
                  key: POSTGRES_PASSWORD
            - name: POSTGRES_DB
              valueFrom:
                secretKeyRef:
                  name: postgres-secrets
                  key: POSTGRES_DB
            - name: BACKUP_RETENTION_DAYS
              valueFrom:
                configMapKeyRef:
                  name: postgres-config
                  key: BACKUP_RETENTION_DAYS
            volumeMounts:
            - name: backup-storage
              mountPath: /backup
          volumes:
          - name: backup-storage
            persistentVolumeClaim:
              claimName: postgres-backup
          restartPolicy: OnFailure

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-backup
  labels:
    component: database
    storage-type: backup
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 50Gi
```

## Security Component

A comprehensive security component that adds security policies and configurations.

**components/security/kustomization.yaml**:
```yaml
apiVersion: kustomize.config.k8s.io/v1alpha1
kind: Component

metadata:
  name: security-component
  annotations:
    config.kubernetes.io/local-config: "true"
    component.kustomize.io/description: "Security hardening component"

resources:
  - network-policy.yaml
  - pod-security-policy.yaml
  - service-account.yaml
  - rbac.yaml

patches:
  - path: security-context.yaml
    target:
      kind: Deployment

commonLabels:
  security.hardened: "true"

commonAnnotations:
  security.kubernetes.io/level: "restricted"
```

**components/security/security-context.yaml**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: placeholder
spec:
  template:
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 2000
        seccompProfile:
          type: RuntimeDefault
      containers:
      - name: placeholder
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
        volumeMounts:
        - name: tmp
          mountPath: /tmp
        - name: var-cache
          mountPath: /var/cache
      volumes:
      - name: tmp
        emptyDir: {}
      - name: var-cache
        emptyDir: {}
```

**components/security/network-policy.yaml**:
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress

---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-app-communication
spec:
  podSelector:
    matchLabels:
      security.hardened: "true"
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          security.hardened: "true"
    - namespaceSelector:
        matchLabels:
          name: ingress-system
  egress:
  - to:
    - podSelector:
        matchLabels:
          security.hardened: "true"
  - to: []  # Allow DNS
    ports:
    - protocol: UDP
      port: 53
```

## Logging Component

A centralized logging component with Fluent Bit.

**components/logging/kustomization.yaml**:
```yaml
apiVersion: kustomize.config.k8s.io/v1alpha1
kind: Component

metadata:
  name: logging-component
  annotations:
    config.kubernetes.io/local-config: "true"
    component.kustomize.io/description: "Centralized logging with Fluent Bit"

resources:
  - fluent-bit-daemonset.yaml
  - fluent-bit-configmap.yaml
  - fluent-bit-service.yaml

patches:
  - path: logging-annotations.yaml
    target:
      kind: Deployment

commonLabels:
  logging.enabled: "true"

configMapGenerator:
  - name: logging-config
    literals:
      - LOG_LEVEL=info
      - LOG_FORMAT=json
      - BUFFER_SIZE=1MB
```

**components/logging/fluent-bit-configmap.yaml**:
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
  labels:
    component: logging
data:
  fluent-bit.conf: |
    [SERVICE]
        Flush         5
        Log_Level     info
        Daemon        off
        Parsers_File  parsers.conf
        HTTP_Server   On
        HTTP_Listen   0.0.0.0
        HTTP_Port     2020

    [INPUT]
        Name              tail
        Path              /var/log/containers/*.log
        Parser            docker
        Tag               kube.*
        Refresh_Interval  5
        Mem_Buf_Limit     50MB
        Skip_Long_Lines   On

    [FILTER]
        Name                kubernetes
        Match               kube.*
        Kube_URL            https://kubernetes.default.svc:443
        Kube_CA_File        /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
        Kube_Token_File     /var/run/secrets/kubernetes.io/serviceaccount/token
        Merge_Log           On
        K8S-Logging.Parser  On
        K8S-Logging.Exclude Off

    [OUTPUT]
        Name  stdout
        Match *

  parsers.conf: |
    [PARSER]
        Name   docker
        Format json
        Time_Key time
        Time_Format %Y-%m-%dT%H:%M:%S.%L
        Time_Keep On
```

## Component Composition Patterns

### 1. Multi-Component Application

**applications/web-app-full/kustomization.yaml**:
```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

metadata:
  name: full-stack-web-app

# Base application
resources:
  - ../../base/web-app

# Compose from multiple components
components:
  - ../../components/database
  - ../../components/monitoring
  - ../../components/security
  - ../../components/logging

# Application-specific configuration
namespace: web-app-full

commonLabels:
  app: web-app
  stack: full

# Application-specific patches
patches:
  - patch: |
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: web-app
      spec:
        template:
          spec:
            containers:
            - name: web-app
              env:
              - name: DATABASE_URL
                value: "postgresql://appuser:changeme123@postgres:5432/appdb"
              - name: ENABLE_METRICS
                value: "true"
              - name: LOG_LEVEL
                value: "info"
```

### 2. Minimal Application

**applications/web-app-minimal/kustomization.yaml**:
```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

metadata:
  name: minimal-web-app

# Base application only
resources:
  - ../../base/web-app

# Only essential components
components:
  - ../../components/security

namespace: web-app-minimal

commonLabels:
  app: web-app
  profile: minimal
```

## Component Libraries and Sharing

### Enterprise Component Library Structure

```
enterprise-components/
├── infrastructure/
│   ├── database/
│   │   ├── postgres/
│   │   ├── mysql/
│   │   └── redis/
│   ├── messaging/
│   │   ├── rabbitmq/
│   │   └── kafka/
│   └── storage/
│       ├── minio/
│       └── nfs/
├── observability/
│   ├── monitoring/
│   ├── logging/
│   ├── tracing/
│   └── alerting/
├── security/
│   ├── network-policies/
│   ├── pod-security/
│   ├── rbac/
│   └── secrets-management/
└── platform/
    ├── ingress/
    ├── service-mesh/
    ├── autoscaling/
    └── backup/
```

### Component Versioning Strategy

**components/monitoring/v1.0.0/kustomization.yaml**:
```yaml
apiVersion: kustomize.config.k8s.io/v1alpha1
kind: Component

metadata:
  name: monitoring-component
  annotations:
    config.kubernetes.io/local-config: "true"
    component.kustomize.io/description: "Prometheus monitoring capabilities"
    component.kustomize.io/version: "1.0.0"
    component.kustomize.io/changelog: |
      1.0.0:
        - Initial release
        - Basic Prometheus ServiceMonitor
        - Standard alerting rules

# Component implementation...
```

### Component Documentation

**components/monitoring/README.md**:
```markdown
# Monitoring Component

## Description
Adds Prometheus monitoring capabilities to any application.

## Version
1.0.0

## Features
- ServiceMonitor for metrics collection
- Standard alerting rules
- Grafana dashboard configuration
- Custom metrics endpoint support

## Usage

```yaml
# kustomization.yaml
components:
  - path/to/components/monitoring
```

## Configuration

The component can be configured through these environment variables:
- `METRICS_PORT`: Port for metrics endpoint (default: 9090)
- `METRICS_PATH`: Path for metrics endpoint (default: /metrics)

## Requirements
- Prometheus Operator installed in cluster
- Application must expose metrics endpoint

## Labels Added
- `monitoring.enabled: "true"`

## Annotations Added
- `prometheus.io/scrape: "true"`
- `prometheus.io/port: "9090"`
- `prometheus.io/path: "/metrics"`
```

## Component Testing and Validation

### Component Test Structure

```bash
components/monitoring/
├── kustomization.yaml
├── tests/
│   ├── test-app/
│   │   ├── kustomization.yaml
│   │   └── deployment.yaml
│   └── expected/
│       └── expected-output.yaml
└── validate.sh
```

**components/monitoring/validate.sh**:
```bash
#!/bin/bash
# Component validation script

set -e

COMPONENT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TEST_DIR="$COMPONENT_DIR/tests"

echo "Validating monitoring component..."

# Test component builds successfully
echo "Testing component build..."
kustomize build "$TEST_DIR/test-app" > /tmp/actual-output.yaml

# Validate against expected output
if [ -f "$TEST_DIR/expected/expected-output.yaml" ]; then
    echo "Comparing with expected output..."
    diff "$TEST_DIR/expected/expected-output.yaml" /tmp/actual-output.yaml || {
        echo "Output doesn't match expected result"
        exit 1
    }
fi

# Validate Kubernetes resources
echo "Validating Kubernetes resources..."
kubectl apply --dry-run=client -f /tmp/actual-output.yaml

# Check for required labels and annotations
echo "Checking required labels and annotations..."
if ! grep -q "monitoring.enabled.*true" /tmp/actual-output.yaml; then
    echo "Missing monitoring.enabled label"
    exit 1
fi

if ! grep -q "prometheus.io/scrape.*true" /tmp/actual-output.yaml; then
    echo "Missing prometheus.io/scrape annotation"
    exit 1
fi

echo "✅ Component validation passed!"
```

## Advanced Component Patterns

### 1. Conditional Components

**components/database/kustomization.yaml**:
```yaml
apiVersion: kustomize.config.k8s.io/v1alpha1
kind: Component

# Component with conditional resources based on environment
resources:
  - postgres-deployment.yaml
  - postgres-service.yaml

# High availability resources only for production
# These would be conditionally included by overlays
# - postgres-replica.yaml
# - postgres-failover.yaml

patches:
  - target:
      kind: Deployment
      name: postgres
    patch: |
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: postgres
      spec:
        template:
          spec:
            containers:
            - name: postgres
              env:
              - name: POSTGRES_HA_MODE
                value: "${POSTGRES_HA_MODE:-single}"
```

### 2. Parameterized Components

**components/monitoring/kustomization.yaml**:
```yaml
apiVersion: kustomize.config.k8s.io/v1alpha1
kind: Component

# Use replacements for parameterization
replacements:
  - source:
      kind: ConfigMap
      name: component-params
      fieldPath: data.metrics_port
    targets:
      - select:
          kind: Service
          name: app-metrics
        fieldPaths:
          - spec.ports.[name=metrics].port
      - select:
          kind: Deployment
        fieldPaths:
          - spec.template.spec.containers.[name=app].ports.[name=metrics].containerPort

configMapGenerator:
  - name: component-params
    literals:
      - metrics_port=9090
      - metrics_path=/metrics
      - scrape_interval=30s
```

### 3. Component Dependencies

**components/observability-stack/kustomization.yaml**:
```yaml
apiVersion: kustomize.config.k8s.io/v1alpha1
kind: Component

metadata:
  name: observability-stack
  annotations:
    component.kustomize.io/dependencies: "monitoring,logging,tracing"

# Compose multiple components
components:
  - ../monitoring
  - ../logging
  - ../tracing

# Add integration configuration
configMapGenerator:
  - name: observability-config
    literals:
      - METRICS_ENABLED=true
      - LOGGING_ENABLED=true
      - TRACING_ENABLED=true
      - CORRELATION_ID_HEADER=X-Correlation-ID
```

## Chapter Summary

In this chapter, we explored Kustomize components and reusability patterns:

### Key Concepts Mastered
- **Component Architecture**: Understanding components vs bases vs overlays
- **Reusable Patterns**: Creating components for infrastructure, security, monitoring, and logging
- **Component Composition**: Mixing and matching components to build complex applications
- **Enterprise Libraries**: Organizing and versioning component libraries for teams

### Practical Skills Developed
- Creating standalone components for common patterns
- Composing applications from multiple components
- Testing and validating component functionality
- Documenting components for team consumption
- Implementing advanced component patterns

### Best Practices Learned
- Design components to be self-contained and reusable
- Version components for backward compatibility
- Document component interfaces and requirements
- Test components in isolation and composition
- Organize component libraries by domain and function

### Component Benefits Realized
- **Code Reuse**: Eliminate duplication across applications
- **Standardization**: Enforce consistent patterns across teams
- **Modularity**: Enable flexible application composition
- **Maintainability**: Centralize common functionality
- **Team Collaboration**: Share expertise through reusable components

Components enable powerful reusability patterns that scale from individual applications to enterprise-wide infrastructure standardization, promoting consistency and reducing maintenance overhead.

---

**Next**: [Chapter 10: Advanced Features](10-advanced-features.md)

**Previous**: [Chapter 8: ConfigMaps and Secrets Generation](08-configmaps-secrets.md)

**Quick Links**: [Table of Contents](../README.md) | [Examples](../examples/chapter-09/)